"""
IA module entrypoint.
"""
from py2neo import Graph  # for connecting to neo4j
import time

# for Ingredient2Vec
from gensim.models import KeyedVectors
import pickle

# pylint: disable=W0511, W0613

def get_recipe(user_ingredients: list, limit=20, startsfrom=0) -> list:
    """ Get recipe from api call.

    Parameters
    ----------
    user_ingredients: list
        list of ingredients
    limit: int
        how many recipes to return
    startsfrom: int
        first ingredient id to return

    Returns
    -------
    list(int)
        all matching recipes ids
        index 0 is the better
    """

    # connect to neo4j
    # TODO : replace in production
    graph = Graph("bolt://localhost:11003", auth=('neo4j', 'pact2020'))

    # all ingredients
    all_ingredients = [i['id'] for i in
                       graph.run("MATCH (i:Ingredient) RETURN id(i) AS id").data()]  # 9ms, very efficient

    # excluded ingredients
    excluded_ingredients = [str(i) for i in all_ingredients if i not in user_ingredients]

    # * recipes that are possible STRICTLY with user ingredients *
    possible_recipes = graph.run("""MATCH (excluded:Ingredient)
    WHERE id(excluded) in [""" + ','.join(excluded_ingredients) + """]
    WITH collect(excluded) as excluded
    MATCH (r:Recipe)-[:HAS_INGREDIENT]->(i)
    WITH excluded, r, collect(i) as ingredients
    WHERE NONE (i in ingredients where i in excluded)
    RETURN id(r) as id SKIP """ + str(startsfrom) + """ LIMIT """ + str(limit)).data()

    # if len(possible_recipes):
    #     return [x['id'] for x in possible_recipes]
    # else:
    #     # search for recipes that are APPROXIMATE matches (1 single ingredient that the user doesn't have)
    #     possible_recipes = graph.run("""MATCH (excluded:Ingredient)
    #         WHERE id(excluded) in [""" + ','.join(excluded_ingredients) + """]
    #         WITH collect(id(excluded)) as excluded
    #         MATCH (r:Recipe)-[:HAS_INGREDIENT]->(i)
    #         WITH excluded, r, collect(id(i)) as ingredients
    #         WHERE SINGLE (i in ingredients where i in excluded)
    #         RETURN id(r) AS id, ingredients SKIP """ + str(startsfrom) + """ LIMIT """ + str(limit)).data()
    #
    #     # load Ingredient2Vec model
    #     try:
    #         with open('../../../db/db_for_ingredient2vec/ingredients-dicts.pickle', 'rb') as handle:
    #             ingredients_dict = pickle.load(handle)
    #     except FileNotFoundError:
    #         print("ERROR : ingredients-dicts.pickle NOT FOUND")
    #     model = KeyedVectors.load_word2vec_format('ingredient2vec.bin')
    #
    #     # find missing ingredients
    #     sim = []
    #     ids = []
    #     print(user_ingredients)
    #     for recipe in possible_recipes:
    #         missing_ing = list(set(recipe['ingredients']).difference(user_ingredients))[0]
    #         name = graph.run("MATCH (i:Ingredient) WHERE id(i)=" + missing_ing + " RETURN i.name AS n").data()[0]['n']
    #         for substitute, simil in model.most_similar(positive=ingredients_dict[name], topn=3):
    #             print(substitute)
    #             # TODO : verify the name
    #             if substitute in user_ingredients:
    #                 sim.append(simil)
    #
    #         # ids = graph.run("""MATCH(r: Recipe)-[h: HAS_INGREDIENT]->(:Ingredient)
    #         # WHERE id(r) = ...
    #         # CALL apoc.refactor.cloneNodesWithRelationships([r, h])
    #         # YIELD input, output
    #         # RETURN *""")
    #
    #         # TODO :create potential recipes
    #         # TODO : find a way to delete recipes generated by AI if not made.
    #
    #     # return ids from possible_recipes ranked by missing_ing substitutable-ness
    #     return [x['id'] for _, x in sorted(zip(sim, possible_recipes))]

# test
start_time = time.time()
get_recipe([0,1])
print("--- %s seconds ---" % (time.time() - start_time))